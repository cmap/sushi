#'  normalize
#'
#'  takes a filtered dataframe of raw read counts and normalizes
#'  counts using control barcodes
#'
#' @param X - dataframe of annotated readcounts that must include the following columns:
#'           log2_n or n: raw readcounts or log2(n) of read counts. Computes log2_n if not present
#'           log_dose: log2 of dose at which control barcode was spiked in, if applicable
#'           sample_ID: some identifier that distinguishes between each sample
#'           Name: contains the name of the control barcode that the read corresponds to, or NA
#'           profile_id: a unique identifier for each sample, as generated by filter_counts
#' @param barcodes - a vector of control barcode Name identifiers
#' @param pseudocount A pseudocount to be added to the counts so that logs can be taken
#' @return - table with additional log_normalized_n and normalized_n columns containing counts normalized to control barcodes
#' @import tidyverse
#' @import magrittr
#' @export
normalize <- function(X, barcodes, pseudocount) {
  # Required functions
  require(tidyverse)
  require(magrittr)
  
  # Create log2_n if it does not exist
  if (!('log2_n' %in% colnames(X)) & 
      ('n' %in% colnames(X))) {
    X %<>% dplyr::mutate(log2_n = log2(n + pseudocount))
  }
  
  # Identify valid profiles and valid control barcodes to determine intercept
  # dropping invalid trt_type, wells without control barcodes, cell line entries or other CBs, cbs with zero reads,
  # and profiles with fewer than 4 CBs.
  valid_profiles= X %>% dplyr::filter(!(trt_type %in% c("empty", "", "CB_only")) & !is.na(trt_type), 
                                      control_barcodes==T, Name %in% barcodes, n!= 0) %>%
    dplyr::group_by(profile_id) %>% dplyr::filter(dplyr::n() > 4) %>% dplyr::ungroup()
  
  # Which profiles were dropped out?
  if(length(unique(valid_profiles$profile_id)) != length(unique(X$profile_id))) {
    # Print error if all profiles were dropped
    if(nrow(valid_profiles) == 0) {
      print('ERROR: No valid profiles for normalization!')
      # Stop run with an error
      stop('No valid profiles detected for normalization!')
    }
    
    # Print out the profiles that were dropped
    profiles_dropped_at_norm= X %>% dplyr::filter(!profile_id %in% unique(valid_profiles$profile_id)) %>%
      dplyr::pull(profile_id) %>% unique()
    print(paste('Number of profiles dropped at normalization:', length(profiles_dropped_at_norm),
                'out of', length(unique(X$profile_id))))
    print('Reason for dropping:\n1. trt type is empty, NA, or CB_only. 2. Detected <=4 CBs.')
    print("Dropped profiles are ...")
    print(profiles_dropped_at_norm)
  }
  
  # Calculate fit intercept for valid profiles using median intercept
  fit_intercepts= valid_profiles %>% dplyr::group_by(profile_id, log2_dose) %>%
    dplyr::summarize(dose_intercept= mean(log2_dose) - mean(log2_n)) %>%
    dplyr::group_by(profile_id) %>%
    dplyr::summarize(cb_intercept= median(dose_intercept)) %>% dplyr::ungroup()
  
  # Calculate fit statistics - MAE and R2
  fit_stats= valid_profiles %>% dplyr::inner_join(fit_intercepts, by='profile_id') %>% 
    dplyr::group_by(profile_id) %>%
    dplyr::mutate(log2_normalized_n= log2_n + cb_intercept,
                  norm_mae= median(abs(log2_dose- log2_normalized_n)),
                  mean_y= mean(log2_dose),
                  residual2= (log2_dose- log2_normalized_n)^2,
                  squares2= (log2_dose- mean_y)^2,
                  norm_r2= 1- sum(residual2)/sum(squares2)) %>% dplyr::ungroup() %>%
    dplyr::distinct(profile_id, cb_intercept, norm_mae, norm_r2)
  
  # Normalize entries
  normalized= X %>% dplyr::inner_join(fit_stats, by='profile_id') %>%
    dplyr::mutate(log2_normalized_n= log2_n + cb_intercept,
                  normalized_n = 2^log2_normalized_n)
  
  return(normalized)
}
