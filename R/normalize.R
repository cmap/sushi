#'  normalize
#'
#'  takes a filtered dataframe of raw read counts and normalizes
#'  counts using control barcodes
#'
#' @param X - dataframe of annotated readcounts that must include the following columns:
#'           log2_n or n: raw readcounts or log2(n) of read counts. Computes log2_n if not present
#'           log_dose: log2 of dose at which control barcode was spiked in, if applicable
#'           sample_ID: some identifier that distinguishes between each sample
#'           Name: contains the name of the control barcode that the read corresponds to, or NA
#'           profile_id: a unique identifier for each sample, as generated by filter_counts
#' @param barcodes - a vector of control barcode Name identifiers
#' @return - table with additional log_normalized_n and normalized_n columns containing counts normalized to control barcodes
#' @export
normalize <- function(X, barcodes) {
  if (!('log2_n' %in% colnames(X)) & 
      ('n' %in% colnames(X))) {
    X <- X %>% dplyr::mutate(log2_n = log2(n+1))
  }

  normalized <- X %>%
    dplyr::filter(!(trt_type %in% c("empty", "", "CB_only")) & !is.na(trt_type), control_barcodes==T) %>% 
    dplyr::group_by(profile_id) %>%
    # filter out profiles with 4 or fewer detected control barcodes
    dplyr::mutate(num_cbs= length(unique(na.omit(Name)))) %>% dplyr::filter(num_cbs > 4) %>%
    dplyr::mutate(cb_intercept = glm(I(y-1*x)~1,
                                     data = dplyr::tibble(
                                       y = log2_dose[Name %in% barcodes],
                                       x = log2_n[Name %in% barcodes]))$coefficients[1],
                  log2_normalized_n= log2_n + cb_intercept) %>%
    dplyr::ungroup() %>%
    dplyr::select(-num_cbs) %>%
    dplyr::mutate(normalized_n = 2^log2_normalized_n)

  return(normalized)
}
